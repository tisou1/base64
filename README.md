## base64编码学习

### typescript实现node/web下的base64编码

[参考链接](https://ptrchm.com/posts/base32-explained/)

### 实现思路

像十进制数字使用10位数字表示数字一样, base $2^n$编码表示数字(字节)的另一种方式,n越大表示就越紧凑
可用位数决定了单个字符可以表示多少位,例如: 使用二进制一位可以表示两种字符组合. 类似的在Base64中(base $2^6$)中,我们可以将6位数据编码为单个字符($2^6$ = 6位的64个字符组合)

**实现的方式有很多种,这里使用的是按位运算方式.**

当拿到要编码的字符串, 会将其转化为对应的Unicode字符集编码数组

```ts
export function strToByte(str: string): Uint8Array {
  const encoder = new TextEncoder()
  return encoder.encode(str)
}
```

如'foobar'字符串就会得到`[102, 111, 111, 98, 97, 114]`的Unit8Array数组

然后根据选择的base $2^n$编码方式,对数组再进行分组.  这里n为6, 一个字节为8个比特位,所以取6和8的最小公倍数24, 也就是说一组24个比特位也就是3 * 8 = 24, 即三个数字为一组分为了`[[102, 111, 111], [ 98, 97, 114]]`

然后再对每组进行分别编码处理, 我们这里选择了按位运算的方式,所以呢,需要将每组的三个数进行按位运算进行拼接,具体的二进制位运算如下
```
01100110 01101111 01101111
f        o        o

01100110 << 8  
0110011000000000 + 01101111 =  0110011001101111 
0110011001101111  << 8
011001100110111100000000 + 01101111 = 011001100110111101101111

第一组最终得到 011001100110111101101111
```

这时候对二进制进行6位一组分开得到  011001 100110 111101 101111

得到的6位二进制,可表示的最大值得范围为0 ~ 2 $6$ = 64 个

这时候就需要我们创建一个长度为64的字符集,来进行编码,这里使用的是[RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648)定义的字符集
即`const BASE64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split('')`

后续需要我们做的就是将上一步得到一组4个6位长度的编码对应到BASE64_ALPHABET的索引取值

> 索引取值这一步, 也需要进行按位移动,一次弹出6个比特位, 代码的实现实录就是利用掩码(0x3f)和向右位移6位来依次取值

```
011001100110111101101111 & 0x3f (63 111111 $2^6$ -1) = 01101111
011001100110111101101111 >> 6 = 011001100110111101

011001100110111101 & 0x3f = 111101
011001100110111101 >> 6 = 011001100110

011001100110 & 0x3f = 100110
011001100110 >> 6 = 011001

011001 & 0x3f = 011001
011001 >> 6 = 0   (此时为0结束比特位移动)
```

将`011001 100110 111101 101111`转为10进制就是`25 38 61 47`对应`BASE64_ALPHABET`的索引结果为`Z m 9 v`

上面都是每组是24比特的, 可能会出现一组不满24比特的情况, 这时候就需要进行补位填充了,当然补的都是0,
比如最后一个只有8个字节,此时肯定不够,所以我们需要补4个比特位凑齐12(大于8的最小能整除6的数)个比特位,这样可以以6个一组进行分
